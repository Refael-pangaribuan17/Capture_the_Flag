from pwn import *

def main():
    r = remote('localhost', 9999)#('chals1.apoorvctf.xyz', 4001)
    
    welcome1 = r.recvline().decode().strip()
    welcome2 = r.recvline().decode().strip()
    print(f"Server says: {welcome1}")
    print(f"Server says: {welcome2}")
    
    def send_and_receive(hex_payload):
        r.recvuntil(b"Enter your input: ")
        r.sendline(hex_payload.encode())
        response = r.recvline().decode().strip()
        if "Ciphertext: " in response:
            return response.split("Ciphertext: ")[1]
        else:
            print(f"Error in response: {response}")
            return None
    
    def parse_blocks(hex_string):
        return [hex_string[i:i+32] for i in range(0, len(hex_string), 32)]
    
    known_flag_hex = "61706f6f7276637466" # hex for 'apoorvctf'
    
    for step in range(6, 0, -1):
        print(f"\n=== Step {7-step}: Initial padding = {step} pairs of 'AA' ===")
        
        initial_payload = "AA" * (step)  
        initial_response = send_and_receive(initial_payload)
        
        if not initial_response:
            print("Failed to get initial response")
            continue
            
        initial_blocks = parse_blocks(initial_response)
        target_block = initial_blocks[0]  
        
        print(f"Initial payload: {initial_payload}")
        print(f"Target block: {target_block}")
        
        found = False
        for byte_val in range(256):
            byte_hex = format(byte_val, '02x')
            test_payload = "AA" * (step) + known_flag_hex + byte_hex
            
            response = send_and_receive(test_payload)
            if not response:
                continue
                
            response_blocks = parse_blocks(response)
            
            if response_blocks[0] == target_block:
                print(f"Found matching byte: 0x{byte_hex}")
                known_flag_hex += byte_hex
                known_flag = bytes.fromhex(known_flag_hex).decode('latin-1')
                print(f"Current flag (hex): {known_flag_hex}")
                print(f"Current flag: {known_flag}")
                found = True
                break
            
            if byte_val % 32 == 31:
                print(f"Tested up to byte value {byte_val}...")
        
        if not found:
            print(f"No matching byte found in step {7-step}. Moving to next step.")
    
    for step in range(16, 0, -1):
        print(f"\n=== Step {23-step}: Block 2 comparison, padding = {step} pairs of 'AA' ===")
        

        initial_payload = "AA" * (step) 
        initial_response = send_and_receive(initial_payload)
        
        if not initial_response:
            print("Failed to get initial response")
            continue
            
        initial_blocks = parse_blocks(initial_response)
        if len(initial_blocks) < 2:
            print("Not enough blocks in response")
            continue
            
        target_block = initial_blocks[1] 
        
        print(f"Initial payload: {initial_payload}")
        print(f"Target block (block 2): {target_block}")
        
        found = False
        for byte_val in range(256):
            byte_hex = format(byte_val, '02x')
            test_payload = "AA" * (step) + known_flag_hex + byte_hex
            
            response = send_and_receive(test_payload)
            if not response:
                continue
                
            response_blocks = parse_blocks(response)
            
            if len(response_blocks) < 2:
                continue

            if response_blocks[1] == target_block:
                print(f"Found matching byte: 0x{byte_hex}")
                known_flag_hex += byte_hex
                known_flag = bytes.fromhex(known_flag_hex).decode('latin-1')
                print(f"Current flag (hex): {known_flag_hex}")
                print(f"Current flag: {known_flag}")
                found = True
                break
            
            if byte_val % 32 == 31:
                print(f"Tested up to byte value {byte_val}...")
        
        if not found:
            print(f"No matching byte found in step {23-step}. Moving to next step.")
    
    print("\n=== Step 23: Finding final character (should be '}') ===")
    known_flag_hex += "7d"  # hex for '}'
    known_flag = bytes.fromhex(known_flag_hex).decode('latin-1')
    print(f"Final flag (hex): {known_flag_hex}")
    print(f"Final flag: {known_flag}")
    print("\n=== Recovery complete ===")
    r.close()

if __name__ == "__main__":
    main()